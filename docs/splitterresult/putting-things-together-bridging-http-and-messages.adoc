ifdef::context[:parent-context: {context}]
[id="putting-things-together-bridging-http-and-messages_{context}"]
= Putting things together - bridging HTTP and messages
:context: putting-things-together-bridging-http-and-messages

Let's revisit a greeting HTTP endpoint and use asynchronous message passing to delegate the call to a separated bean.
It uses the request/reply dispatching mechanism.
Instead of implementing the business logic inside the JAX-RS endpoint, we are sending a message.
This message is consumed by another bean and the response is sent using the _reply_ mechanism.

First create a new project using:

[source,subs="attributes+"]
----
mvn io.quarkus:quarkus-maven-plugin:{quarkus-version}:create \
    -DprojectGroupId=org.acme \
    -DprojectArtifactId=vertx-http-quickstart \
    -Dextensions="vertx"
cd vertx-http-quickstart
----

You can already start the application in _dev mode_ using `./mvnw compile quarkus:dev`.

Then, creates a new JAX-RS resource with the following content:

.src/main/java/org/acme/vertx/EventResource.java
[source,java]
----
package org.acme.vertx;

import io.smallrye.mutiny.Uni;
import io.vertx.mutiny.core.eventbus.EventBus;
import io.vertx.mutiny.core.eventbus.Message;
import org.jboss.resteasy.annotations.jaxrs.PathParam;

import javax.inject.Inject;
import javax.ws.rs.GET;
import javax.ws.rs.Path;
import javax.ws.rs.Produces;
import javax.ws.rs.core.MediaType;

@Path("/async")
public class EventResource {

    @Inject
    EventBus bus;

    @GET
    @Produces(MediaType.TEXT_PLAIN)
    @Path("{name}")
    public Uni<String> greeting(@PathParam String name) {
        return bus.<String>request("greeting", name)            // <1>
                .onItem().apply(Message::body);            // <2>
    }
}
----

[arabic]
<1> send the `name` to the `greeting` address and request a response
<2> when we get the response, extract the body and send it to the user

If you call this endpoint, you will wait and get a timeout. Indeed, no one is listening.
So, we need a consumer listening on the `greeting` address. Create a `GreetingService` bean with the following content:

.src/main/java/org/acme/vertx/GreetingService.java
[source,java]
----
package org.acme.vertx;

import io.quarkus.vertx.ConsumeEvent;

import javax.enterprise.context.ApplicationScoped;

@ApplicationScoped
public class GreetingService {

    @ConsumeEvent("greeting")
    public String greeting(String name) {
        return "Hello " + name;
    }

}
----

This bean receives the name, and returns the greeting message.

Now, open your browser to http://localhost:8080/async/Quarkus, and you should see:

[source,text]
----
Hello Quarkus
----

To better understand, let's detail how the HTTP request/response has been handled:

[arabic]
. The request is received by the `hello` method
. a message containing the _name_ is sent to the event bus
. Another bean receives this message and computes the response
. This response is sent back using the reply mechanism
. Once the reply is received by the sender, the content is written to the HTTP response

This application can be packaged using:

[source,shell]
----
./mvnw clean package
----

You can also compile it as a native executable with:

[source,shell]
----
./mvnw clean package -Pnative
----


ifdef::parent-context[:context: {parent-context}]
ifndef::parent-context[:!context:]