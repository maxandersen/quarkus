ifdef::context[:parent-context: {context}]
[id="imperative-usage_{context}"]
= Imperative usage
:context: imperative-usage

Sometimes you need to have an imperative way of sending messages.

For example, if you need to send a message to a stream from inside a REST endpoint when receiving a POST request.
In this case, you cannot use `@Outgoing` because your method has parameters.

For this, you can use an `Emitter`.

[source,java]
----
import org.eclipse.microprofile.reactive.messaging.Channel;
import org.eclipse.microprofile.reactive.messaging.Emitter;

import javax.inject.Inject;
import javax.ws.rs.POST;
import javax.ws.rs.Path;
import javax.ws.rs.Consumes;
import javax.ws.rs.core.MediaType;

@Path("/prices")
public class PriceResource {

    @Inject @Channel("price-create") Emitter<Double> priceEmitter;

    @POST
    @Consumes(MediaType.TEXT_PLAIN)
    public void addPrice(Double price) {
        priceEmitter.send(price);
    }
}
----

[NOTE,textlabel="Note",name="note"]
====
The `Emitter` configuration is done the same way as the other stream configuration used by `@Incoming` and `@Outgoing`.
In addition, you can use `@OnOverflow` to configure a back-pressure strategy.
====

.Deprecation
[NOTE,textlabel="Note",name="note"]
====
The `io.smallrye.reactive.messaging.annotations.Emitter`, `io.smallrye.reactive.messaging.annotations.Channel` and `io.smallrye.reactive.messaging.annotations.OnOverflow` classes are now deprecated and replaced by:* `org.eclipse.microprofile.reactive.messaging.Emitter`
* `org.eclipse.microprofile.reactive.messaging.Channel`
* `org.eclipse.microprofile.reactive.messaging.OnOverflow`The new `Emitter.send` method returns a `CompletionStage` completed when the produced message is acknowledged.
====


ifdef::parent-context[:context: {parent-context}]
ifndef::parent-context[:!context:]