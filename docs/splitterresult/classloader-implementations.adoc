ifdef::context[:parent-context: {context}]
[id="classloader-implementations_{context}"]
= ClassLoader Implementations
:context: classloader-implementations

Quarkus has the following ClassLoaders:

Base ClassLoader:: This is usually the normal JVM System ClassLoader. In some environments such as Maven it may be different. This ClassLoader
is used to load the bootstrap classes, and other ClassLoader instances will delegate the loading of JDK classes to it.
Augment ClassLoader:: This loads all the `-deployment` artifacts and their dependencies, as well as other user dependencies. It does not load the
application root or any hot deployed code. This ClassLoader is persistent, even if the application restarts it will remain
(which is why it cannot load application classes that may be hot deployed). Its parent is the base ClassLoader, and it is
transformer safe.

At present this can be configured to delegate to the Base ClassLoader, however the plan is for this option to go away and
always have this as an isolated ClassLoader. Making this an isolated ClassLoader is complicated as it means that all
the builder classes are isolated, which means that use cases that want to customise the build chains are slightly more complex.

Deployment ClassLoader:: This can load all application classes, its parent is the Augment ClassLoader so it can also load all deployment classes.

This ClassLoader is non-persistent, it will be re-created when the application is started, and is isolated. This ClassLoader
is the context ClassLoader that is used when running the build steps. It is also transformer safe.

Base Runtime ClassLoader:: This loads all the runtime extension dependencies, as well as other user dependencies (note that this may include duplicate
copies of classes also loaded by the Augment ClassLoader). It does not load the application root or any hot deployed
code. This ClassLoader is persistent, even if the application restarts it will remain (which is why it cannot load
application classes that may be hot deployed). Its parent is the base ClassLoader.

This loads code that is not hot-reloadable, but it does support transformation (although once the class is loaded this
transformation is no longer possible). This means that only transformers registered in the first application start
will take effect, however as these transformers are expected to be idempotent this should not cause problems. An example
of the sort of transformation that might be required here is a Panache entity packaged in an external jar. This class
needs to be transformed to have its static methods implemented, however this transformation only happens once, so
restarts use the copy of the class that was created on the first start.

This ClassLoader is isolated from the Augment and Deployment ClassLoaders. This means that it is not possible to set
values in a static field in the deployment side, and expect to read it at runtime. This allows dev and test applications
to behave more like a production application (production applications are isolated in that they run in a whole new JVM).

This also means that the runtime version can be linked against a different set of dependencies, e.g. the hibernate
version used at deployment time might want to include ByteBuddy, while the version used at runtime does not.

Runtime Class Loader:: This ClassLoader is used to load the application classes and other hot deployable resources. Its parent is the base runtime
ClassLoader, and it is recreated when the application is restarted.


ifdef::parent-context[:context: {parent-context}]
ifndef::parent-context[:!context:]