ifdef::context[:parent-context: {context}]
[id="hibernate-orm-in-development-mode_{context}"]
= Hibernate ORM in development mode
:context: hibernate-orm-in-development-mode

Quarkus development mode is really useful for applications that mix front end or services and database access.

There are a few common approaches to make the best of it.

The first choice is to use `quarkus.hibernate-orm.database.generation=drop-and-create` in conjunction with `import.sql`.

That way for every change to your app and in particular to your entities, the database schema will be properly recreated
and your data fixture (stored in `import.sql`) will be used to repopulate it from scratch.
This is best to perfectly control your environment and works magic with Quarkus live reload mode:
your entity changes or any change to your `import.sql` is immediately picked up and the schema updated without restarting the application!

[TIP,textlabel="Tip",name="tip"]
====
By default in `dev` and `test` modes, Hibernate ORM, upon boot, will read and execute the SQL statements in the `/import.sql` file (if present).
You can change the file name by changing the property `quarkus.hibernate-orm.sql-load-script` in `application.properties`.
====

The second approach is to use `quarkus.hibernate-orm.database.generation=update`.
This approach is best when you do many entity changes but
still need to work on a copy of the production data
or if you want to reproduce a bug that is based on specific database entries.
`update` is a best effort from Hibernate ORM and will fail in specific situations
including altering your database structure which could lead to data loss.
For example if you change structures which violate a foreign key constraint, Hibernate ORM might have to bail out.
But for development, these limitations are acceptable.

The third approach is to use `quarkus.hibernate-orm.database.generation=none`.
This approach is best when you are working on a copy of the production data but want to fully control the schema evolution.
Or if you use a database schema migration tool like https://quarkus.io/guides/flyway[Flyway].

With this approach when making changes to an entity, make sure to adapt the database schema accordingly;
you could also use `validate` to have Hibernate verify the schema matches its expectations.

[WARNING,textlabel="Warning",name="warning"]
====
Do not use `quarkus.hibernate-orm.database.generation` `drop-and-create` and `update` in your production environment.
====

These approaches become really powerful when combined with Quarkus configuration profiles.
You can define different https://quarkus.io/guides/config#configuration-profiles[configuration profiles]
to select different behaviors depending on your environment.
This is great because you can define different combinations of Hibernate ORM properties matching the development style you currently need.

.application.properties
[source]
----
%dev.quarkus.hibernate-orm.database.generation = drop-and-create
%dev.quarkus.hibernate-orm.sql-load-script = import-dev.sql

%dev-with-data.quarkus.hibernate-orm.database.generation = update
%dev-with-data.quarkus.hibernate-orm.sql-load-script = no-file

%prod.quarkus.hibernate-orm.database.generation = none
%prod.quarkus.hibernate-orm.sql-load-script = no-file
----

.Start "dev mode" using a custom profile via Maven
[source,bash]
----
./mvnw compile quarkus:dev -Dquarkus.profile=dev-with-data
----


ifdef::parent-context[:context: {parent-context}]
ifndef::parent-context[:!context:]