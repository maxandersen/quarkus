ifdef::context[:parent-context: {context}]
[id="using-response_{context}"]
= Using Response
:context: using-response

Let's create the `Legume` class which will be serialized as JSON, following the same model as for our `Fruit` class:

[source,JAVA]
----
package org.acme.rest.json;

public class Legume {

    public String name;
    public String description;

    public Legume() {
    }

    public Legume(String name, String description) {
        this.name = name;
        this.description = description;
    }
}
----

Now let's create a `LegumeResource` REST service with only one method which returns the list of legumes.

This method returns a `Response` and not a list of `Legume`.

[source,JAVA]
----
package org.acme.rest.json;

import java.util.Collections;
import java.util.LinkedHashSet;
import java.util.Set;

import javax.ws.rs.Consumes;
import javax.ws.rs.GET;
import javax.ws.rs.Path;
import javax.ws.rs.Produces;
import javax.ws.rs.core.MediaType;
import javax.ws.rs.core.Response;

@Path("/legumes")
@Produces(MediaType.APPLICATION_JSON)
@Consumes(MediaType.APPLICATION_JSON)
public class LegumeResource {

    private Set<Legume> legumes = Collections.synchronizedSet(new LinkedHashSet<>());

    public LegumeResource() {
        legumes.add(new Legume("Carrot", "Root vegetable, usually orange"));
        legumes.add(new Legume("Zucchini", "Summer squash"));
    }

    @GET
    public Response list() {
        return Response.ok(legumes).build();
    }
}
----

Now let's add a simple web page to display our list of legumes.
In the `src/main/resources/META-INF/resources` directory, add a `legumes.html` file with the content from this
{quickstarts-blob-url}/rest-json-quickstart/src/main/resources/META-INF/resources/legumes.html[legumes.html] file in it.

Open a browser to http://localhost:8080/legumes.html and you will see our list of legumes.

The interesting part starts when running the application as a native executable:

* create the native executable with `./mvnw package -Pnative`.
* execute it with `./target/rest-json-quickstart-1.0-SNAPSHOT-runner`
* open a browser and go to http://localhost:8080/legumes.html

No legumes there.

As mentioned above, the issue is that Quarkus was not able to determine the `Legume` class will require some reflection by analyzing the REST endpoints.
The JSON serialization library tries to get the list of fields of `Legume` and gets an empty list so it does not serialize the fields' data.

[NOTE,textlabel="Note",name="note"]
====
At the moment, when JSON-B or Jackson tries to get the list of fields of a class, if the class is not registered for reflection, no exception will be thrown.
GraalVM will simply return an empty list of fields.Hopefully, this will change in the future and make the error more obvious.
====

We can register `Legume` for reflection manually by adding the `@RegisterForReflection` annotation on our `Legume` class:

[source,JAVA]
----
import io.quarkus.runtime.annotations.RegisterForReflection;

@RegisterForReflection
public class Legume {
    // ...
}
----

Let's do that and follow the same steps as before:

* hit `Ctrl+C` to stop the application
* create the native executable with `./mvnw package -Pnative`.
* execute it with `./target/rest-json-quickstart-1.0-SNAPSHOT-runner`
* open a browser and go to http://localhost:8080/legumes.html

This time, you can see our list of legumes.


ifdef::parent-context[:context: {parent-context}]
ifndef::parent-context[:!context:]