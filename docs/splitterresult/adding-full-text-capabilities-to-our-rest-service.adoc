ifdef::context[:parent-context: {context}]
[id="adding-full-text-capabilities-to-our-rest-service_{context}"]
= Adding full text capabilities to our REST service
:context: adding-full-text-capabilities-to-our-rest-service

In our existing `LibraryResource`, we just need to inject the following methods (and add a few ``import``s):

[source,java]
----
    @Transactional // <1>
    void onStart(@Observes StartupEvent ev) throws InterruptedException { // <2>
        // only reindex if we imported some content
        if (Book.count() > 0) {
            Search.session(em)
                    .massIndexer()
                    .startAndWait();
        }
    }

    @GET
    @Path("author/search") // <3>
    @Transactional
    public List<Author> searchAuthors(@QueryParam String pattern, // <4>
            @QueryParam Optional<Integer> size) {
        return Search.session(em) // <5>
                .search(Author.class) // <6>
                .where(f ->
                    pattern == null || pattern.trim().isEmpty() ?
                            f.matchAll() : // <7>
                            f.simpleQueryString()
                                .fields("firstName", "lastName", "books.title").matching(pattern) // <8>
                )
                .sort(f -> f.field("lastName_sort").then().field("firstName_sort")) // <9>
                .fetchHits(size.orElse(20)); // <10>
    }
----

[arabic]
<1> Important point: we need a transactional context for these methods.
<2> As we will import data into the PostgreSQL database using an SQL script, we need to reindex the data at startup.
For this, we use Hibernate Search's mass indexer, which allows to index a lot of data efficiently (you can fine tune it for better performances).
All the upcoming updates coming through Hibernate ORM operations will be synchronized automatically to the full text index.
If you don't import data manually in the database, you don't need that:
the mass indexer should then only be used when you change your indexing configuration (adding a new field, changing an analyzer's configuration...) and you want the new configuration to be applied to your existing entities.
<3> This is where the magic begins: just adding the annotations to our entities makes them available for full text search: we can now query the index using the Hibernate Search DSL.
<4> Use the `org.jboss.resteasy.annotations.jaxrs.QueryParam` annotation type to avoid repeating the parameter name.
<5> First, we get an Hibernate Search session from the injected entity manager.
<6> We indicate that we are searching for ``Author``s.
<7> We create a predicate: if the pattern is empty, we use a `matchAll()` predicate.
<8> If we have a valid pattern, we create a https://www.elastic.co/guide/en/elasticsearch/reference/current/query-dsl-simple-query-string-query.html[`simpleQueryString()`] predicate on the `firstName`, `lastName` and `books.title` fields matching our pattern.
<9> We define the sort order of our results. Here we sort by last name, then by first name. Note that we use the specific fields we created for sorting.
<10> Fetch the `size` top hits, `20` by default. Obviously, paging is also supported.

[NOTE,textlabel="Note",name="note"]
====
The Hibernate Search DSL supports a significant subset of the Elasticsearch predicates (match, range, nested, phrase, spatial...).
Feel free to explore the DSL using autocompletion.When that's not enough, you can always fall back to
[defining a predicate using JSON directly](https://docs.jboss.org/hibernate/search/6.0/reference/en-US/html_single/#search-dsl-predicate-extensions-elasticsearch-from-json).
====


ifdef::parent-context[:context: {parent-context}]
ifndef::parent-context[:!context:]