ifdef::context[:parent-context: {context}]
[id="mutiny_{context}"]
= Mutiny - A reactive programming library
:context: mutiny

https://github.com/smallrye/smallrye-mutiny[Mutiny] is a reactive programming library allowing to express and compose asynchronous actions.
It offers 2 types:

* `io.smallrye.mutiny.Uni` - for asynchronous action providing 0 or 1 result
* `io.smallrye.mutiny.Multi` - for multi-item (with back-pressure) streams

Both types are lazy and follow a subscription pattern.
The computation only starts once there is an actual need for it (i.e. a subscriber enlists).

[source,java]
----
uni.subscribe().with(
    result -> System.out.println("result is " + result),
    failure -> failure.printStackTrace()
);

multi.subscribe().with(
    item -> System.out.println("Got " + item),
    failure -> failure.printStackTrace()
);
----

Both `Uni` and `Multi` expose event-driven APIs: you express what you want to do upon a given event (success, failure, etc.).
These APIs are divided into groups (types of operations) to make it more expressive and avoid having 100s of methods attached to a single class.
The main types of operations are about reacting to failure, completion, manipulating items, extracting, or collecting them.
It provides a smooth coding experience, with a navigable API, and the result does not require too much knowledge around reactive.

[source,java]
----
httpCall
    .onFailure().recoverWithItem("my fallback");
----

You may wonder about Reactive Streams (https://www.reactive-streams.org/).
`Multi` implements Reactive Streams `Publisher`, and so implements the Reactive Streams back-pressure mechanism.
`Uni` does not implement `Publisher` as the subscription to the `Uni` is enough to indicate you are interested in the result.
It is again with the idea of simpler and smoother APIs in mind as the Reactive Streams subscription/request ceremony is more complex.

Embracing the unification of reactive and imperative pillars from Quarkus, both `Uni` and `Multi` provide bridges to imperative constructs.
For example, you can transform a `Multi` into an `Iterable` or _await_ the item produced by a `Uni`.

[source,java]
----
// Block until the result is available
String result = uni.await().indefinitely();

// Transform an asynchronous stream into a blocking iterable
stream.subscribe().asIterable().forEach(s -> System.out.println("Item is " + s));
----

At that point, if you are a RxJava or a Reactor user, you may wonder how you can use your familiar `Flowable`, `Single`, `Flux`, `Mono`...
Mutiny allows converting `Unis` and `Multis` from and to RX Java and Reactor types:

[source,java]
----
Maybe<String> maybe = uni.convert().with(UniRxConverters.toMaybe());
Flux<String> flux = multi.convert().with(MultiReactorConverters.toFlux());
----

But, what about Vert.x?
Vert.x APIs are also available using Mutiny types.
The following snippet shows a usage of the Vert.x Web Client:

[source,java]
----
// Use io.vertx.mutiny.ext.web.client.WebClient
client = WebClient.create(vertx,
                new WebClientOptions().setDefaultHost("fruityvice.com").setDefaultPort(443).setSsl(true)
                        .setTrustAll(true));
// ...
Uni<JsonObject> uni =
    client.get("/api/fruit/" + name)
        .send()
        .onItem().apply(resp -> {
            if (resp.statusCode() == 200) {
                return resp.bodyAsJsonObject();
            } else {
                return new JsonObject()
                        .put("code", resp.statusCode())
                        .put("message", resp.bodyAsString());
            }
        });
----

Last but not least, Mutiny has built-in integration with MicroProfile Context Propagation so you can propagate transactions, traceability data, and so on in your reactive pipeline.

But enough talking, let's get our hands dirty!


ifdef::parent-context[:context: {parent-context}]
ifndef::parent-context[:!context:]