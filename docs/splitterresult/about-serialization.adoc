ifdef::context[:parent-context: {context}]
[id="about-serialization_{context}"]
= About serialization
:context: about-serialization

JSON serialization libraries use Java reflection to get the properties of an object and serialize them.

When using native executables with GraalVM, all classes that will be used with reflection need to be registered.
The good news is that Quarkus does that work for you most of the time.
So far, we haven't registered any class, not even `Fruit`, for reflection usage and everything is working fine.

Quarkus performs some magic when it is capable of inferring the serialized types from the REST methods.
When you have the following REST method, Quarkus determines that `Fruit` will be serialized:

[source,JAVA]
----
@GET
@Produces("application/json")
public List<Fruit> list() {
    // ...
}
----

Quarkus does that for you automatically by analyzing the REST methods at build time
and that's why we didn't need any reflection registration in the first part of this guide.

Another common pattern in the JAX-RS world is to use the `Response` object.
`Response` comes with some nice perks:

* you can return different entity types depending on what happens in your method (a `Legume` or an `Error` for instance);
* you can set the attributes of the `Response` (the status comes to mind in the case of an error).

Your REST method then looks like this:

[source,JAVA]
----
@GET
@Produces("application/json")
public Response list() {
    // ...
}
----

It is not possible for Quarkus to determine at build time the type included in the `Response` as the information is not available.
In this case, Quarkus won't be able to automatically register for reflection the required classes.

This leads us to our next section.


ifdef::parent-context[:context: {parent-context}]
ifndef::parent-context[:!context:]