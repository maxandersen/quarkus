[id="query-projection_{context}"]
= Query projection

Query projection can be done with the `project(Class)` method on the `PanacheQuery` object that is returned by the `find()` methods.

You can use it to restrict which fields will be returned by the database,
the ID field will always be returned, but it's not mandatory to include it inside the projection class.

For this, you need to create a class (a POJO) that will only contain the projected fields.
This POJO needs to be annotated with `@ProjectionFor(Entity.class)` where `Entity` is the name of your entity class.
The field names, or getters, of the projection class will be used to restrict which properties will be loaded from the database.

Projection can be done for both PanacheQL and native queries.

[source,java]
----
import io.quarkus.mongodb.panache.ProjectionFor;
import org.bson.codecs.pojo.annotations.BsonProperty;

// using public fields
@ProjectionFor(Person.class)
public class PersonName {
    public String name;
}

// using getters
@ProjectionFor(Person.class)
public class PersonNameWithGetter {
    private String name;

    public String getName(){
        return name;
    }

    public void setName(String name){
        this.name = name;
    }
}

// only 'name' will be loaded from the database
PanacheQuery<PersonName> shortQuery = Person.find("status ", Status.Alive).project(PersonName.class);
PanacheQuery<PersonName> query = Person.find("'status': ?1", Status.Alive).project(PersonNameWithGetter.class);
PanacheQuery<PersonName> nativeQuery = Person.find("{'status': 'ALIVE'}", Status.Alive).project(PersonName.class);
----

[TIP,textlabel="Tip",name="tip"]
====
Using `@BsonProperty` is not needed to define custom column mappings, as the mappings from the entity class will be used.
====

[TIP,textlabel="Tip",name="tip"]
====
You can have your projection class extends from another class. In this case, the parent class also needs to have use `@ProjectionFor` annotation.
====