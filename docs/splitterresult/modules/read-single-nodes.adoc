[id="read-single-nodes_{context}"]
= Read single nodes

This time, we ask for a read-only transaction.
We also add some exception handling, in case the resource is called with an invalid id:

.src/main/java/org/acme/neo4j/FruitResource.java
[source,java]
----
@GET
@Path("{id}")
public CompletionStage<Response> getSingle(@PathParam("id") Long id) {
    AsyncSession session = driver.asyncSession();
    return session
        .readTransactionAsync(tx -> tx
            .runAsync("MATCH (f:Fruit) WHERE id(f) = $id RETURN f", Values.parameters("id", id))
            .thenCompose(fn -> fn.singleAsync())
    )
    .handle((record, exception) -> {
        if(exception != null) {
            Throwable source = exception;
            if(exception instanceof CompletionException) {
                source = ((CompletionException)exception).getCause();
            }
            Status status = Status.INTERNAL_SERVER_ERROR;
            if(source instanceof NoSuchRecordException) {
                status = Status.NOT_FOUND;
            }
            return Response.status(status).build();
        } else  {
            return Response.ok(Fruit.from(record.get("f").asNode())).build();
        }
    })
    .thenCompose(response -> session.closeAsync().thenApply(signal -> response));
}
----

A request may look like this:

[source,shell]
----
curl localhost:8080/fruits/42
----

[NOTE,textlabel="Note",name="note"]
====
In case Neo4j has been setup as a cluster, the transaction mode is used to decide whether a request is routed
      to a leader or a follower instance. Write transactions must be handled by a leader, whereas read-only transactions
      can be handled by followers.
====