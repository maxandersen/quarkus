[id="reactive_{context}"]
= Going reactive

If you have access to Neo4j 4.0, you can go fully reactive.

To make life a bit easier, we will use https://smallrye.io/smallrye-mutiny/[Mutiny] for this.

.Mutiny
[TIP,textlabel="Tip",name="tip"]
====
The following example uses Mutiny reactive types, if you're not familiar with them, read the link:getting-started-reactive#mutiny[Getting Started with Reactive guide] first.
====

Add the following dependency to your `pom.xml`:

[source,xml]
----
<dependencies>
    <dependency>
        <groupId>io.quarkus</groupId>
        <artifactId>quarkus-resteasy-mutiny</artifactId>
    </dependency>
</dependencies>
----

The reactive fruit resources streams the name of all fruits:

.src/main/java/org/acme/neo4j/ReactiveFruitResource.java
[source,java]
----
package org.acme.neo4j;

import javax.inject.Inject;
import javax.ws.rs.Consumes;
import javax.ws.rs.GET;
import javax.ws.rs.Path;
import javax.ws.rs.Produces;
import javax.ws.rs.core.MediaType;

import io.smallrye.mutiny.Multi;
import io.smallrye.mutiny.Uni;
import org.neo4j.driver.Driver;
import org.neo4j.driver.reactive.RxResult;
import org.reactivestreams.Publisher;


@Path("reactivefruits")
@Produces(MediaType.APPLICATION_JSON)
@Consumes(MediaType.APPLICATION_JSON)
public class ReactiveFruitResource {

    @Inject
    Driver driver;

    @GET
    @Produces(MediaType.SERVER_SENT_EVENTS)
    public Publisher<String> get() {
        // Create a stream from a resource we can close in a finalizer:
        return Multi.createFrom().resource(driver::rxSession,
                session -> session.readTransaction(tx -> {
                    RxResult result = tx.run("MATCH (f:Fruit) RETURN f.name as name ORDER BY f.name");
                    return Multi.createFrom().publisher(result.records())
                            .map(record -> record.get("name").asString());
                })
        ).withFinalizer(session -> {
            return Uni.createFrom().publisher(session.close());
        });
    }
}
----

`driver.rxSession()` returns a reactive session.
It exposes its API based on http://www.reactive-streams.org[Reactive Streams], most prominently, as `org.reactivestreams.Publisher`.
Those can be used directly, but we found it easier and more expressive to wrap them in reactive types such as the one provided by Mutiny.
Typically, in the previous code, the session is closed when the stream completes, fails or the subscriber cancels.