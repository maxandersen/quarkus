[id="bytecode-recording_{context}"]
= Bytecode Recording

One of the main outputs of the build process is recorded bytecode. This bytecode actually sets up the runtime environment. For example, in order to start Undertow, the resulting application will have some bytecode that directly registers all
Servlet instances and then starts Undertow.

As writing bytecode directly is complex, this is instead done via bytecode recorders. At deployment time,
invocations are made on recorder objects that contain the actual runtime logic, but instead of these invocations
proceeding as normal they are intercepted and recorded (hence the name). This recording is then used to generate bytecode
that performs the same sequence of invocations at runtime. This is essentially a form of deferred execution where invocations
made at deployment time get deferred until runtime.

Let's look at the classic 'Hello World' type example. To do this the Quarkus way we would create a recorder as follows:

[source,java,nowrap-option=""]
----
@Recorder
class HelloRecorder {

  public void sayHello(String name) {
    System.out.println("Hello" + name);
  }

}
----

And then create a build step that uses this recorder:

[source,java,nowrap-option=""]
----
@Record(RUNTIME_INIT)
@BuildStep
public void helloBuildStep(HelloRecorder recorder) {
    recorder.sayHello("World");
}
----

When this build step is run nothing is printed to the console. This is because the `HelloRecorder` that is injected is
actually a proxy that records all invocations. Instead if we run the resulting Quarkus program we will see 'Hello World'
printed to the console.

Methods on a recorder can return a value, which must be proxiable (if you want to return a non-proxiable item wrap it
in `io.quarkus.runtime.RuntimeValue`). These proxies may not be invoked directly, however they can be passed
into other recorder methods. This can be any recorder method, including from other `@BuildStep` methods, so a common pattern
is to produce `BuildItem` instances that wrap the results of these recorder invocations.

For instance, in order to make arbitrary changes to a Servlet deployment Undertow has a `ServletExtensionBuildItem`,
which is a `MultiBuildItem` that wraps a `ServletExtension` instance. I can return a `ServletExtension` from a recorder
in another module, and Undertow will consume it and pass it into the recorder method that starts Undertow.

At runtime the bytecode will be invoked in the order it is generated. This means that build step dependencies implicitly
control the order that generated bytecode is run. In the example above we know that the bytecode that produces a
`ServletExtensionBuildItem` will be run before the bytecode that consumes it.

[id="recordercontext_{context}"]
== RecorderContext
:context: recordercontext