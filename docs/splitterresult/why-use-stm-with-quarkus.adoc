ifdef::context[:parent-context: {context}]
[id="why-use-stm-with-quarkus_{context}"]
= Why use STM with Quarkus?
:context: why-use-stm-with-quarkus

Now you may still be asking yourself "Why STM instead of JTA?" or "What are the benefits
to STM that I don't get from JTA?" Let's try to answer those or similar questions, with
a particular focus on why we think they're great for Quarkus, microservices and Kubernetes
native applications. So in no specific order ...

* The goal of STM is to simplify object reads and writes from multiple threads/protect
state from concurrent updates. The Quarkus STM implementation will safely manage any conflicts between
these threads using whatever isolation model has been chosen to protect that specific state
instance (object in the case of Quarkus). In Quarkus STM, there are two isolation implementations,
pessimistic (the default), which would cause conflicting threads to be blocked until the original
has completed its updates (committed or aborted the transaction); then there's the optimistic
approach which allows all of the threads to proceed and checks for conflicts at commit time, where
one or more of the threads may be forced to abort if there have been conflicting updates.
* STM objects have state but it doesn't need to be persistent (durable). In fact the
default behaviour is for objects managed within transactional memory to be volatile, such that
if the service or microservice within which they are being used crashes or is spawned elsewhere, e.g.,
by a scheduler, all state in memory is lost and the objects start from scratch. But surely you get this and more
with JTA (and a suitable transactional datastore) and don't need to worry about restarting your application?
Not quite. There's a trade-off here: we're doing away
with persistent state and the overhead of reading from and then writing (and sync-ing) to the datastore during each
transaction. This makes updates to (volatile) state very fast but you still get the benefits of atomic updates
across multiple STM objects (e.g., objects your team wrote then calling objects you inherited from another team and requiring
them to make all-or-nothing updates), as well as consistency
and isolation in the presence of concurrent threads/users (common in distributed microservices architectures).
Furthermore, not all stateful applications need to be durable - even when JTA transactions are used, it tends to be the
exception and not the rule. And as you'll see later, because applications can optionally start and control transactions, it's possible to build microservices which can undo state changes and try alternative paths.
* Another benefit of STM is composability and modularity. You can write concurrent Quarkus objects/services that
can be easily composed with any other services built using STM, without exposing the details of how the objects/services
are implemented. As we discussed earlier, this ability to compose objects you wrote with those other teams may have
written weeks, months or years earlier, and have A, C and I properties can be hugely beneficial. Furthermore, some
STM implementations, including the one Quarkus uses, support nested transactions and these allow changes made within
the context of a nested (sub) transaction to later be rolled back by the parent transaction.
* Although the default for STM object state is volatile, it is possible to configure the STM implementation
such that an object's state is durable. Although it's possible to configure Narayana such that different
backend datastores can be used, including relational databases, the default is the local operating system
file system, which means you don't need to configure anything else with Quarkus such as a database.
* Many STM implementations allow "plain old language objects" to be made STM-aware with little or no changes to
the application code. You can build, test and deploy applications without wanting them to be STM-aware and
then later add those capabilities if they become necessary and without much development overhead at all.


ifdef::parent-context[:context: {parent-context}]
ifndef::parent-context[:!context:]