ifdef::context[:parent-context: {context}]
[id="usage-example-with-mutiny_{context}"]
= Usage example with Mutiny
:context: usage-example-with-mutiny

.Mutiny
[TIP,textlabel="Tip",name="tip"]
====
This section uses Mutiny reactive types, if you're not familiar with them, read the link:getting-started-reactive#mutiny[Getting Started with Reactive guide] first.
====

Let's write a REST endpoint that reads the next 3 items from a link:kafka[Kafka topic], stores them in a database using
link:hibernate-orm-panache[Hibernate ORM with Panache] (all in the same transaction) before returning
them to the client, you can do it like this:

[source,java]
----
    // Get the prices stream
    @Inject
    @Channel("prices") Publisher<Double> prices;

    @Transactional
    @GET
    @Path("/prices")
    @Produces(MediaType.SERVER_SENT_EVENTS)
    @SseElementType(MediaType.TEXT_PLAIN)
    public Publisher<Double> prices() {
        // get the next three prices from the price stream
        return Multi.createFrom().publisher(prices)
                .transform().byTakingFirstItems(3)
                .map(price -> {
                    // store each price before we send them
                    Price priceEntity = new Price();
                    priceEntity.value = price;
                    // here we are all in the same transaction
                    // thanks to context propagation
                    priceEntity.persist();
                    return price;
                    // the transaction is committed once the stream completes
                });
    }
----

Notice that thanks to Mutiny support for context propagation, this works out of the box.
The 3 items are persisted using the same transaction and this transaction is committed when the stream completes.


ifdef::parent-context[:context: {parent-context}]
ifndef::parent-context[:!context:]