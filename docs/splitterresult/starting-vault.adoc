ifdef::context[:parent-context: {context}]
[id="starting-vault_{context}"]
= Starting Vault
:context: starting-vault

Let's start Vault in development mode:

[source,shell,subs="attributes+"]
----
docker run --rm --cap-add=IPC_LOCK -e VAULT_ADDR=http://localhost:8200 -p 8200:8200 -d --name=dev-vault vault:{vault-version}
----

You can check that vault is running with:

[source,shell,subs="attributes+"]
----
docker logs dev-vault
----

You should see:

[source,shell,subs="attributes+"]
----
==> Vault server configuration:

             Api Address: http://0.0.0.0:8200
                     Cgo: disabled
         Cluster Address: https://0.0.0.0:8201
              Listener 1: tcp (addr: "0.0.0.0:8200", cluster address: "0.0.0.0:8201", max_request_duration: "1m30s", max_request_size: "33554432", tls: "disabled")
               Log Level: info
                   Mlock: supported: true, enabled: false
                 Storage: inmem
                 Version: Vault v{vault-version}

WARNING! dev mode is enabled! In this mode, Vault runs entirely in-memory
and starts unsealed with a single unseal key. The root token is already
authenticated to the CLI, so you can immediately begin using Vault.

You may need to set the following environment variable:

    $ export VAULT_ADDR='http://0.0.0.0:8200'

The unseal key and root token are displayed below in case you want to
seal/unseal the Vault or re-authenticate.

Unseal Key: 0lZ2/vzpa92pH8gersSn2h9b5tmzd4m5sqIdMC/4PDs=
Root Token: {root-token}

Development mode should NOT be used in production installations!

==> Vault server started! Log data will stream in below:
----

In development mode, Vault gets configured with several options that makes it convenient:

* Vault is already initialized with one key share (whereas in normal mode this has to be done explicitly and the
number of key shares is 5 by default)
* the unseal key and the root token are displayed in the logs (please write down the root token, we will need it
in the following step)
* Vault is unsealed
* in-memory storage
* TLS is disabled
* a _kv secret engine v2_ is mounted at `secret/`

In the following step, we are going to add a `userpass` authentication that we will use from the Quarkus application,
to access a secret stored in the _kv secret engine_.

First open a shell inside the vault container:

[source,shell,subs="attributes+"]
----
docker exec -it dev-vault sh
----

Set the `VAULT_TOKEN` with the value that was printed in the logs:

[source,shell,subs="attributes+"]
----
export VAULT_TOKEN={root-token}
----

You can check Vault's status using the CLI command `vault status`:

[source,shell]
----
Key             Value
---             -----
Seal Type       shamir
Initialized     true
Sealed          false
Total Shares    1
Threshold       1
Version         1.2.2
Cluster Name    vault-cluster-b07e80d8
Cluster ID      55bd74b6-eaaf-3862-f7ce-3473ab86c57f
HA Enabled      false
----

For simplicity reasons, we are going to use a _kv secret engine version 1_ (which is the default) mounted at path
`secret` instead of the pre-configured _kv version 2_ available in dev mode. So let's disable the current kv engine,
and recreate a new one:

[source,shell]
----
# this will disable the current kv version 2 secret engine mounted at path 'secret'
vault secrets disable secret

# this will enable a new kv engine version 1 at path 'secret'
vault secrets enable -path=secret kv
----

Now let's add a secret configuration for our application:

[source,shell]
----
vault kv put secret/myapps/vault-quickstart/config a-private-key=123456
----

We have defined a path `secret/myapps/vault-quickstart` in Vault that we need to give access to from the Quarkus application.

Create a policy that gives read access to `secret/myapps/vault-quickstart` and subpaths:

[source,shell]
----
cat <<EOF | vault policy write vault-quickstart-policy -
path "secret/myapps/vault-quickstart/*" {
  capabilities = ["read"]
}
EOF
----

[NOTE,textlabel="Note",name="note"]
====
When using a _kv secret engine version 2_, secrets are written and fetched at path `<mount>/*data*/<secret-path>`
as opposed to `<mount>/<secret-path>` in a _kv secret engine version 1_.
It does not change any of the CLI commands (i.e. you do not specify `data` in your path).
However it does change the policies, since capabilities are applied to the real path. In the example above,
the path should be `secret/*data*/myapps/vault-quickstart/*` if you were working with a _kv secret engine version 2_.
====

And finally, let's enable the _userpass auth secret engine_, and create user `bob` with access to the `vault-quickstart-policy`:

[source,shell]
----
vault auth enable userpass
vault write auth/userpass/users/bob password=sinclair policies=vault-quickstart-policy
----

[NOTE,textlabel="Note",name="note"]
====
The Vault extension also supports alternate authentication methods such as:- https://www.vaultproject.io/docs/auth/approle.html[approle]
- https://www.vaultproject.io/docs/auth/kubernetes.html[kubernetes] when deploying the Quarkus application
and Vault into KubernetesIt is also possible to directly pass a `quarkus.vault.authentication.client-token`, which will bypass the authentication process.
This could be handy in development where revocation and ttl are not a concern.Check the extension configuration documentation for more information.
====

To check that the configuration is correct, try logging in:

[source,shell]
----
vault login -method=userpass username=bob password=sinclair
----

You should see:

[source,shell,subs="attributes+"]
----
Success! You are now authenticated. The token information displayed below
is already stored in the token helper. You do NOT need to run "vault login"
again. Future Vault requests will automatically use this token.

Key                    Value
---                    -----
token                  {client-token}
token_accessor         OKNipTAgxWbxsrjixASNiwdY
token_duration         768h
token_renewable        true
token_policies         ["default" "vault-quickstart-policy"]
identity_policies      []
policies               ["default" "vault-quickstart-policy"]
token_meta_username    bob
----

Now set `VAULT_TOKEN` to the `token` above (instead of the root token), and try reading the vault-quickstart secret config:

[source,shell,subs="attributes+"]
----
export VAULT_TOKEN={client-token}
vault kv get secret/myapps/vault-quickstart/config
----

You should see:

[source,shell]
----
======== Data ========
Key              Value
---              -----
a-private-key    123456
----


ifdef::parent-context[:context: {parent-context}]
ifndef::parent-context[:!context:]